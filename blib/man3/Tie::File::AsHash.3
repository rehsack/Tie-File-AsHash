.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Tie::File::AsHash 3"
.TH Tie::File::AsHash 3 "2005-02-02" "perl v5.8.5" "User Contributed Perl Documentation"
.SH "NAME"
Tie::File::AsHash \- Like Tie::File but access lines using a hash instead of an
array
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Tie::File::AsHash;
.Ve
.PP
.Vb 2
\& tie my %hash, 'Tie::File::AsHash', 'filename', split => ':'
\&        or die "Problem tying %hash: $!";
.Ve
.PP
.Vb 9
\& print $hash{foo};                  # access hash value via key name
\& $hash{foo} = "bar";                # assign new value
\& my @keys = keys %hash;             # get the keys
\& my @values = values %hash;         # ... and values
\& exists $hash{perl};                # check for existence
\& delete $hash{baz};                 # delete line from file
\& $hash{newkey} = "perl";            # entered at end of file
\& while (($key,$val) = each %hash)   # iterate through hash
\& %hash = ();                        # empty file
.Ve
.PP
.Vb 1
\& untie %hash;                       # all done
.Ve
.PP
Here is sample text that would work with the above code when contained in a
file:
.PP
.Vb 3
\& foo:baz
\& key:val
\& baz:whatever
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Tie::File::AsHash\*(C'\fR uses \f(CW\*(C`Tie::File\*(C'\fR and perl code so files can be tied to
hashes.  \f(CW\*(C`Tie::File\*(C'\fR does all the hard work while \f(CW\*(C`Tie::File::AsHash\*(C'\fR works
a little magic of its own.
.PP
The module was initially written for managing htpasswd-format password files.
.SH "USAGE"
.IX Header "USAGE"
.Vb 3
\& use Tie::File::AsHash;
\& tie %hash, 'Tie::File::AsHash', 'filename', split => ':'
\&        or die "Problem tying %hash: $!";
.Ve
.PP
.Vb 1
\& (use %hash like a regular ol' hash)
.Ve
.PP
.Vb 1
\& untie %hash;  # changes saved to disk
.Ve
.PP
Easy enough eh?
.PP
New key/value pairs are appended to the end of the file, \f(CW\*(C`delete\*(C'\fR removes lines
from the file, \f(CW\*(C`keys\*(C'\fR and \f(CW\*(C`each\*(C'\fR work as expected, and so on.
.PP
\&\f(CW\*(C`Tie::File::AsHash\*(C'\fR will not die or exit if there is a problem tying a
file, so make sure to check the return value and check \f(CW$!\fR as the examples do.
.Sh "\s-1OPTIONS\s0"
.IX Subsection "OPTIONS"
The only argument \f(CW\*(C`Tie::File::AsHash\*(C'\fR requires is the \*(L"split\*(R" option, besides
a filename.  The split option's value is the delimiter that exists in the file
between the key and value portions of the line.  It may be a regular
expression, and if so, the \*(L"join\*(R" option must be used to tell
\&\f(CW\*(C`Tie::File::AsHash\*(C'\fR what to stick between the key and value when writing
to the file.  Otherwise, the module dies with an error message.
.PP
.Vb 2
\& tie %hash, 'Tie::File::AsHash', 'filename',  split => qr(\es+), join => " "
\&        or die "Problem tying %hash: $!";
.Ve
.PP
Obviously no one wants lines like \*(L"key(?\-xism:\es+)val\*(R" in their files. 
.PP
All other options are passed directly to \f(CW\*(C`Tie::File\*(C'\fR, so read its
documentation for more information.
.SH "CAVEATS"
.IX Header "CAVEATS"
When \f(CW\*(C`keys\*(C'\fR, \f(CW\*(C`values\*(C'\fR, or \f(CW\*(C`each\*(C'\fR is used on the hash, the values are
returned in the same order as the data exists in the file, from top to
bottom, though this behavior should not be relied on and is subject to change
at any time (but probably never will).
.PP
\&\f(CW\*(C`Tie::File::AsHash\*(C'\fR doesn't force keys to be unique.  If there are multiple
keys, the first key in the file, starting at the top, is used. However, when
\&\f(CW\*(C`keys\*(C'\fR, \f(CW\*(C`values\*(C'\fR, or \f(CW\*(C`each\*(C'\fR is used on the hash, every key/value combination
is returned, including duplicates, triplicates, etc.
.PP
Keys can't contain the split character.  Look at the perl code that
\&\f(CW\*(C`Tie::File::AsHash\*(C'\fR is comprised of to see why (look at the regexes).  Using
a regex for the split value may be one way around this issue.
.PP
\&\f(CW\*(C`Tie::File::AsHash\*(C'\fR hasn't been optimized much.  Maybe it doesn't need to be.
Optimization could add overhead.  Maybe there can be options to turn on and off
various types of optimization?
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Sh "changepass.pl"
.IX Subsection "changepass.pl"
\&\f(CW\*(C`changepass.pl\*(C'\fR changes password file entries when the lines are of
\&\*(L"user:encryptedpass\*(R" format.  It can also add users.
.PP
.Vb 1
\& #!/usr/bin/perl -w
.Ve
.PP
.Vb 2
\& use strict;
\& use Tie::File::AsHash;
.Ve
.PP
.Vb 2
\& die "Usage: $0 user password" unless @ARGV == 2;
\& my ($user, $newpass) = @ARGV;
.Ve
.PP
.Vb 2
\& tie my %users, 'Tie::File::AsHash', '/pwdb/users.txt', split => ':'
\&     or die "Problem tying %hash: $!";
.Ve
.PP
.Vb 2
\& # username isn't in the password file? see if the admin wants it added
\& unless (exists $users{$user}) {
.Ve
.PP
.Vb 3
\&         print "User '$user' not found in db.  Add as a new user? (y/n)\en";
\&         chomp(my $y_or_n = <STDIN>);
\&         set_pw($user, $newpass) if $y_or_n =~ /^[yY]/;
.Ve
.PP
.Vb 1
\& } else {
.Ve
.PP
.Vb 2
\&         set_pw($user, $newpass);
\&         print "Done.\en";
.Ve
.PP
.Vb 1
\& }
.Ve
.PP
.Vb 1
\& sub set_pw { $users{$_[0]} = crypt($_[1], "AA") }
.Ve
.Sh "Using the join option"
.IX Subsection "Using the join option"
Here's code that would allow the delimiter to be ':' or '#' but prefers '#':
.PP
.Vb 1
\& tie my %hash, 'Tie::File::AsHash', 'filename', split => qr/[:#]/, join => "#" or die $!;
.Ve
.PP
Say you want to be sure no ':' delimiters exist in the file:
.PP
.Vb 1
\& while (my ($key, $val) = each %hash) {
.Ve
.PP
.Vb 1
\&        $hash{$key} = $val;
.Ve
.PP
.Vb 1
\& }
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Chris Angell <chris@chrisangell.com>
.PP
Feel free to email me with suggestions, fixes, etc.
.PP
Thanks to Mark Jason Dominus for authoring the superb Tie::File module.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2004, Chris Angell.  All Rights Reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, including any version of Perl 5.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), \fIperltie\fR\|(1), \fITie::File\fR\|(1)
